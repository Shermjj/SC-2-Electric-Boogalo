# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Generate Fourier Transform Matrix
#'
#' This function computes the Fourier transform terms for a given vector of time points.
#' It constructs a matrix with sine and cosine terms up to the specified harmonic order `K`.
#' Each row corresponds to a time point, with interleaved sine and cosine values for
#' frequencies from `1` to `K`.
#'
#' @param time_counter A numeric vector of time points at which the Fourier terms are evaluated.
#' @param K An integer specifying the number of harmonics to include in the transformation.
#' @param period A double indicating the period with respect to which the frequencies are calculated.
#'
#' @return A numeric matrix where each row corresponds to a time point in `time_counter`.
#'         Each row contains `2 * K` entries: for each k from 1 to K, there is a sine term
#'         followed by a cosine term corresponding to the k-th harmonic.
#'
#' @examples
#' time_vec <- seq(0, 10, length.out = 100)
#' K_value <- 5
#' period_value <- 10
#' fourier_matrix <- GenFT(time_vec, K_value, period_value)
#' dim(fourier_matrix) # should be 100 x 10
#'
#' @export
GenFT <- function(time_counter, K, period) {
    .Call(`_ElecForecast_GenFT`, time_counter, K, period)
}

#' Radial Basis Function (RBF) Kernel Matrix Computation
#'
#' This function computes the RBF kernel matrix for a given matrix of input features `X`.
#' The RBF kernel is also known as the Gaussian kernel. It is a measure of similarity
#' between rows in `X` that decays exponentially with the squared Euclidean distance
#' between rows. Each element `K(i, j)` of the output matrix `K` is computed as:
#' \deqn{K(i, j) = \sigma^2 * exp(-||X[i, ] - X[j, ]||^2 / (2 * l^2))}
#' where `||X[i, ] - X[j, ]||` is the Euclidean distance between row `i` and `j` of `X`,
#' `l` is the length scale of the kernel, and `sigma` is the scale parameter.
#'
#' @param X A numeric matrix where each row represents an observation and each column represents a feature.
#' @param l A double specifying the length scale of the kernel.
#' @param sigma A double specifying the scale parameter of the kernel.
#'
#' @return A symmetric numeric matrix of size equal to the number of rows in `X`.
#'         This matrix is the RBF kernel matrix, where each element represents the
#'         similarity between the corresponding pair of observations in `X`.
#'
#' @examples
#' # Generate some data
#' X <- matrix(rnorm(50), nrow=10)
#' # Compute the RBF kernel with length scale 1 and sigma 1
#' K <- rbf_kernel(X, 1, 1)
#' print(K)
#'
#' @export
rbf_kernel <- function(X, l, sigma) {
    .Call(`_ElecForecast_rbf_kernel`, X, l, sigma)
}

#' Matrix Multiplier Worker for Parallel Matrix Multiplication
#'
#' This worker class is used for parallel computation of the matrix product `X'X`
#' where `X'` is the transpose of `X`. The class uses the RcppParallel package to
#' leverage multicore processing, improving performance for large matrices.
#'
#' @section Fields:
#' \itemize{
#'   \item \code{X}: Constant reference to an `arma::mat` representing the input matrix.
#'   \item \code{XtX}: Reference to an `arma::mat` where the result `X'X` is stored.
#' }
#'
#' @section Methods:
#' \describe{
#'   \item{Constructor}{Initializes the class with the input matrix and the output matrix references.}
#'   \item{operator()}{Performs the matrix multiplication operation over a specified range of rows, to be used by RcppParallel.}
#' }
#'
#' @details
#' The operator() method is designed to be called by RcppParallel, and it divides the task of computing
#' the matrix multiplication across multiple threads. Each thread computes a portion of the resulting
#' matrix, specifically, the contributions to `XtX` from rows `begin` to `end` of matrix `X`.
#'
#' @examples
#' \dontrun{
#' library(Rcpp)
#' library(RcppParallel)
#' sourceCpp("path/to/MatrixMultiplier.cpp") // Ensure this path points to the file containing the class
#'
#' # Create a random matrix
#' X <- matrix(rnorm(100 * 10), ncol = 10)
#' XtX <- matrix(0, ncol = 10, nrow = 10)
#'
#' # Create and use the worker
#' worker <- MatrixMultiplier(X, XtX)
#' parallelFor(0, nrow(X), worker)
#'
#' print(XtX) # This should print the result of X'X
#' }
#'
#' @importFrom Rcpp sourceCpp
#' @importFrom RcppParallel parallelFor
#' @export
#'
NULL

#' Ridge Regression with Intercept
#'
#' Performs ridge regression on a given set of predictors and a response variable. 
#' This function adds an intercept to the model by appending a column of ones to 
#' the predictor matrix `X`. It computes the ridge regression coefficients by 
#' penalizing the magnitude of the coefficients through a regularization term `lambda`.
#' The intercept term is not penalized.
#'
#' @param X A numeric matrix of predictor variables where each row is an observation 
#'          and each column is a predictor.
#' @param y A numeric vector of the response variable corresponding to each observation.
#' @param lambda A numeric value specifying the regularization strength (lambda >= 0).
#'
#' @return An R list containing:
#' \itemize{
#'   \item \code{error}: The mean squared error of the model residuals.
#'   \item \code{coefficients}: A numeric vector of the estimated coefficients, including the intercept.
#' }
#'
#' @details
#' The regularization term is added to the diagonal of the cross-product matrix of the
#' predictors (including the intercept), except for the first diagonal element which corresponds
#' to the intercept. This adjustment ensures that the intercept is not shrunk towards zero.
#' The solution to the ridge regression problem is computed using the matrix inversion lemma,
#' which ensures numerical stability and efficiency.
#'
#' @examples
#' \dontrun{
#' library(Rcpp)
#' sourceCpp("path/to/RidgeReg.cpp") // Ensure this path points to the file containing the function
#'
#' # Simulate some data
#' set.seed(123)
#' X <- matrix(rnorm(100 * 10), ncol = 10)
#' y <- X %*% rnorm(10) + rnorm(100)
#' lambda <- 0.5
#'
#' # Perform ridge regression
#' results <- RidgeReg(X, y, lambda)
#' print(results$error)
#' print(results$coefficients)
#' }
#'
#' @importFrom Rcpp sourceCpp
#' @export
RidgeReg <- function(X, y, lambda) {
    .Call(`_ElecForecast_RidgeReg`, X, y, lambda)
}

#' Parallel Ridge Regression with Intercept
#'
#' Computes the coefficients of a ridge regression model using parallel computing
#' to handle the matrix multiplications. The function includes an intercept in the
#' model by appending a column of ones to the matrix `X`. It uses parallelization
#' to efficiently compute the cross-product matrix `X'X`, and it applies ridge
#' regularization by adding a lambda penalty to the diagonal elements of the matrix,
#' except for the intercept term.
#'
#' @param X A numeric matrix of predictor variables, where each row represents an 
#'          observation and each column a predictor.
#' @param y A numeric vector of the response variable corresponding to each observation.
#' @param lambda A double specifying the strength of the regularization (lambda >= 0).
#'
#' @return An R list containing:
#' \itemize{
#'   \item \code{error}: The mean squared error of the model residuals.
#'   \item \code{coefficients}: A numeric vector of the estimated coefficients, including the intercept.
#' }
#'
#' @details
#' The function utilizes the `RcppParallel` package for parallel processing. It employs
#' the `MatrixMultiplier` worker class to perform the multiplication of `X'X` in parallel,
#' speeding up the computation significantly, especially for large datasets. The intercept
#' is not regularized, consistent with standard ridge regression practices.
#'
#' @examples
#' \dontrun{
#' library(Rcpp)
#' library(RcppParallel)
#' sourceCpp("path/to/RidgeRegPar.cpp") // Ensure this path points to the file containing the function
#'
#' # Simulate some data
#' set.seed(123)
#' X <- matrix(rnorm(100 * 10), ncol = 10)
#' y <- X %*% rnorm(10) + rnorm(100)
#' lambda <- 0.5
#'
#' # Perform parallel ridge regression
#' results <- RidgeRegPar(X, y, lambda)
#' print(results$error)
#' print(results$coefficients)
#' }
#'
#' @importFrom Rcpp sourceCpp
#' @importFrom RcppParallel parallelFor
#' @export
RidgeRegPar <- function(X, y, lambda) {
    .Call(`_ElecForecast_RidgeRegPar`, X, y, lambda)
}

#' Perform Cross-Validation for Ridge Regression with Fourier Transform Features
#'
#' This function performs k-fold cross-validation for ridge regression models on a dataset
#' with options to include Fourier transform features for both daily and annual periodic components.
#' It leverages parallel computation to efficiently handle large datasets and multiple model configurations.
#'
#' @param x_vars Numeric matrix of predictor variables.
#' @param y_var Numeric vector of response variable.
#' @param time_counter Numeric vector representing time points for generating Fourier terms.
#' @param daily_period Double specifying the period for daily Fourier terms.
#' @param annual_period Double specifying the period for annual Fourier terms.
#' @param max_K Integer specifying the maximum number of harmonics to consider.
#' @param lambda_values Vector of doubles representing different lambda values for ridge penalty.
#' @param n_folds Integer specifying the number of folds for cross-validation.
#'
#' @return A list containing the optimal number of harmonics (`best_K`), the optimal lambda value (`best_lambda`),
#'         the mean squared error results for each model configuration (`mse_results`), and the final model trained on the entire dataset (`final_model`).
#'
#' @details The function first generates Fourier terms for daily and annual periods up to the maximum number of harmonics specified by `max_K`.
#' It then evaluates the performance of ridge regression models across different combinations of lambda values and number of harmonics
#' using the specified number of folds for cross-validation.
#' The function identifies the best performing model configuration in terms of mean squared error and uses it to train a final model on the entire dataset.
#' This final model and its parameters are returned as part of the results list.
#'
#' @examples
#' \dontrun{
#' x_vars <- matrix(rnorm(1000), ncol = 10)
#' y_var <- rnorm(100)
#' time_counter <- seq(1, 100, by = 1)
#' results <- parallel_ridge_cross_validation(x_vars, y_var, time_counter, 1, 365, 5, c(0.1, 1, 10), 10)
#' print(results$best_lambda)
#' print(results$best_K)
#' print(results$mse_results)
#' print(results$final_model)
#' }
#' @importFrom Rcpp sourceCpp
#' @importFrom RcppParallel parallelFor
#' @export
parallel_ridge_cross_validation <- function(x_vars, y_var, time_counter, daily_period, annual_period, max_K, lambda_values, n_folds) {
    .Call(`_ElecForecast_parallel_ridge_cross_validation`, x_vars, y_var, time_counter, daily_period, annual_period, max_K, lambda_values, n_folds)
}

#' Make Predictions Using a Trained Parallel Ridge Regression Model
#'
#' This function uses a trained parallel ridge regression model to make predictions on new test data. It also computes and returns the mean squared error of the predictions.
#'
#' @param model A list containing the trained ridge regression model and its parameters.
#' @param x_test Numeric matrix of new test predictor variables.
#' @param y_test Numeric vector of new test response variables.
#' @param time_counter Numeric vector representing time points for generating Fourier terms.
#' @param daily_period Double specifying the period for daily Fourier terms.
#' @param annual_period Double specifying the period for annual Fourier terms.
#'
#' @return A list containing the mean squared error (`error`) and the predictions.
#'
#' @examples
#' \dontrun{
#' # Assuming `results` is obtained from `parallel_ridge_cross_validation`
#' test_data <- matrix(rnorm(200), ncol = 10)
#' test_response <- rnorm(20)
#' prediction_results <- predict_parallel_ridge_cv(results$final_model, test_data, test_response, seq(1, 20, by = 1), 1, 365)
#' print(prediction_results$error)
#' print(prediction_results$predictions)
#' }
#' @importFrom Rcpp sourceCpp
#' @export
predict_parallel_ridge_cv <- function(model, x_test, y_test, time_counter, daily_period, annual_period) {
    .Call(`_ElecForecast_predict_parallel_ridge_cv`, model, x_test, y_test, time_counter, daily_period, annual_period)
}

